
<!DOCTYPE html>






<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />


















  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="I have a dream! change the world~">
<meta property="og:type" content="website">
<meta property="og:title" content="Rhino">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Rhino">
<meta property="og:description" content="I have a dream! change the world~">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rhino">
<meta name="twitter:description" content="I have a dream! change the world~">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Rhino</title>









</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">






  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">


    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rhino</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>

        <p class="site-subtitle"></p>

  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">



    <ul id="menu" class="menu">


        <li class="menu-item menu-item-home">
          <a href="/" rel="section">

              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />

            Home
          </a>
        </li>


        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">

              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />

            Archives
          </a>
        </li>



    </ul>



</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">

  <section id="posts" class="posts-expand">









  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">



  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/28/协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="立志当大神">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rhino">
    </span>


      <header class="post-header">



          <h1 class="post-title" itemprop="name headline">

                <a class="post-title-link" href="/2020/11/28/协议/" itemprop="url">协议</a></h1>


        <div class="post-meta">
          <span class="post-time">

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

                <span class="post-meta-item-text">Posted on</span>

              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-28T11:01:34+08:00">
                2020-11-28
              </time>





          </span>
















        </div>
      </header>





    <div class="post-body" itemprop="articleBody">











    </div>










    <footer class="post-footer">








        <div class="post-eof"></div>

    </footer>
  </div>



  </article>











  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">



  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/29/2020-07-29-Sequence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="立志当大神">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rhino">
    </span>


      <header class="post-header">



          <h1 class="post-title" itemprop="name headline">

                <a class="post-title-link" href="/2020/07/29/2020-07-29-Sequence/" itemprop="url">音频初见</a></h1>


        <div class="post-meta">
          <span class="post-time">

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

                <span class="post-meta-item-text">Posted on</span>

              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-29T00:00:00+08:00">
                2020-07-29
              </time>





          </span>
















        </div>
      </header>





    <div class="post-body" itemprop="articleBody">







            <h1 id="音频初见"><a href="#音频初见" class="headerlink" title="音频初见"></a>音频初见</h1><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>音频: 从形式上分为<br>短音频(音效播放):不需要进度|循环等控制  AudioToolbox.framework<br>(C语言框架 </p>
<ul>
<li>本质:将音频注册到system sound service(简单底层的声音播放服务))<br>特点:</li>
<li>播放时间不超过30s</li>
<li>数据格式PCM/IMA4</li>
<li>音频文件必须打包成.caf,.aif,.wav,(.MP3也可以)</li>
</ul>
<p>长音频(音乐播放) </p>
<ul>
<li>较大的音频文件,需要进行精确的控制的场景     </li>
<li>AVFoundation.framework</li>
<li>支持的音频格式有:AAC,ALAC,HE-AAC,iLBC,IMA4,MP3等.</li>
</ul>
<h3 id="音效播放"><a href="#音效播放" class="headerlink" title="音效播放"></a>音效播放</h3><p>步骤:</p>
<ul>
<li>不要忘记导入头文件: #import \&lt;AudioToolbox/AudioToolbox.h></li>
<li>1.调用AudioServicesCreateSystemSoundID(CFURLRef  inFileURL, SystemSoundID*   outSystemSoundID)函数获得系统声音ID。</li>
<li>2.如果需要监听播放完成操作，则使用AudioServicesAddSystemSoundCompletion(  SystemSoundID inSystemSoundID,CFRunLoopRef  inRunLoop, CFStringRef  inRunLoopMode, AudioServicesSystemSoundCompletionProc  inCompletionRoutine, void*  inClientData)方法注册回调函数。</li>
<li>3.调用AudioServicesPlaySystemSound(SystemSoundID inSystemSoundID)<br>  AudioServicesPlayAlertSound(SystemSoundID inSystemSoundID) 方法播放音效（后者带有震动效果）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (void)audioBox&#123;</span><br><span class="line"></span><br><span class="line">//获取资源路径</span><br><span class="line">NSString *pathSource = [[NSBundle mainBundle]pathForResource:@&quot;audiobox&quot; ofType:@&quot;.caf&quot;];</span><br><span class="line">NSURL *sourceUrl = [NSURL fileURLWithPath:pathSource];</span><br><span class="line"></span><br><span class="line">//系统声音id</span><br><span class="line">SystemSoundID soundID =  0;</span><br><span class="line">/**</span><br><span class="line">注册音效服务</span><br><span class="line"></span><br><span class="line">@param inFileURL#&gt; 音频文件URL 需要桥接-&gt;C语言</span><br><span class="line">@param outSystemSoundID#&gt; 输出音效ID</span><br><span class="line">@return 将音效文件加入到系统音频服务中并返回一个长整型音频ID</span><br><span class="line">*/</span><br><span class="line">AudioServicesCreateSystemSoundID((__bridge CFURLRef)(sourceUrl), &amp;soundID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">添加播放完毕回调函数</span><br><span class="line"></span><br><span class="line">@param inSystemSoundID#&gt; 音效ID</span><br><span class="line">@param inRunLoop#&gt; 添加到Runloop</span><br><span class="line">@param inRunLoopMode#&gt; RunloopMode</span><br><span class="line">@param inCompletionRoutine#&gt; 回调函数</span><br><span class="line">@param inClientData#&gt; 传递给回调函数的相关数据</span><br><span class="line">@return ..</span><br><span class="line">*/</span><br><span class="line">AudioServicesAddSystemSoundCompletion(soundID, NULL, NULL, playCompletion, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//播放</span><br><span class="line">AudioServicesPlayAlertSound(soundID); //播放音效并震动</span><br><span class="line">//    AudioServicesPlaySystemSound(soundID); //播放音效</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">回调函数</span><br><span class="line"></span><br><span class="line">@param ssID 音效id</span><br><span class="line">@param clientData 回调时传递的数据</span><br><span class="line">*/</span><br><span class="line">void playCompletion(SystemSoundID ssID, void* __nullable clientData)&#123;</span><br><span class="line">NSLog(@&quot;播放完成&quot;);</span><br><span class="line">//摧毁音效</span><br><span class="line">AudioServicesDisposeSystemSoundID(ssID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="音乐播放-AVAudioPlayer"><a href="#音乐播放-AVAudioPlayer" class="headerlink" title="音乐播放 AVAudioPlayer"></a>音乐播放 AVAudioPlayer</h3><p>AVAudioPlayer支持多种音频格式,而且能够对进度,音量,播放速度等控制<br>头文件 #import \&lt;AVFoundation/AVFoundation.h><br>步骤:</p>
<ul>
<li>1.给定资源路径,或者二进制数据初始化播放器</li>
<li>2.设置相关属性</li>
<li>3.执行播放,更新相关UI(进度更新,歌词显示(CADislinkplay/NSTimer))</li>
</ul>
<h4 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h4><p>AVAudioPlayer可以接受本地资源路径(NSURL)/NSData类型数据(可以用来加载网络链接),但是实质上AVAudioPlayer不支持流式播放,只能播放完整的文件,使用后者加载网络链接,当播放的音频文件较大或者网络不好就需要过长的时间等待<br>每一个实例化方法返回一个AVAudioPlayer对象,每一个文件/Data对应一个AVAudioPlayer对象,传入一个NSError的指针,用于判断初始化是否成功.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable instancetype)initWithContentsOfURL:(NSURL *)url error:(NSError **)outError;</span><br><span class="line">- (nullable instancetype)initWithData:(NSData *)data error:(NSError **)outError;</span><br></pre></td></tr></table></figure>
<h4 id="播放控制相关API"><a href="#播放控制相关API" class="headerlink" title="播放控制相关API"></a>播放控制相关API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//准备播放,分配播放所需的资源，并将其加入内部播放队列,加载音频文件到缓冲区，注意:即使在播放之前音频文件没有加载到缓冲区程序也会隐式调用此方法。</span><br><span class="line">- (BOOL)prepareToPlay;</span><br><span class="line">//播放,如果资源还没准备好,会隐式调用prepareToPlay方法,是异步的</span><br><span class="line">- (BOOL)play;</span><br><span class="line">//相对当前设备时间或指定的时间开始播放音频</span><br><span class="line">- (BOOL)playAtTime:(NSTimeInterval)time </span><br><span class="line"></span><br><span class="line">NSTimeInterval nowTime = self.audioPlayer.deviceCurrentTime;</span><br><span class="line">[self.audioPlayer playAtTime:nowTime + 2.0];</span><br><span class="line"></span><br><span class="line">//暂停播放 并且准备好继续播放</span><br><span class="line">- (void)pause;          /* pauses playback, but remains ready to play. */</span><br><span class="line">//停止播放 不再准备好继续播放,再次调用会重新开始播放</span><br><span class="line">- (void)stop;           /* stops playback. no longer ready to play. */</span><br></pre></td></tr></table></figure>
<h4 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//获取是否正在播放</span><br><span class="line">@property(readonly, getter=isPlaying) BOOL playing;</span><br><span class="line">//获取当前音频声道数</span><br><span class="line">@property(readonly) NSUInteger numberOfChannels;</span><br><span class="line">//获取当前音频时长</span><br><span class="line">@property(readonly) NSTimeInterval duration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取创建时的音频路径 跟初始化方法相关联</span><br><span class="line">@property(readonly, nullable) NSURL *url;</span><br><span class="line">//获取创建时的音频数据 跟初始化方法相关联</span><br><span class="line">@property(readonly, nullable) NSData *data;</span><br><span class="line">//声道 -1.0~0.0左声道 0.0临界值 0.0~1.0为右声道</span><br><span class="line">@property float pan</span><br><span class="line">//音量 正常范围在0.0~1.0</span><br><span class="line">@property float volume;</span><br><span class="line">- (void)setVolume:(float)volume fadeDuration:(NSTimeInterval)duration NS_AVAILABLE(10_12, 10_0); /* fade to a new volume over a duration */</span><br><span class="line"></span><br><span class="line">//是否可以改变播放速率 必须在prepareToPlay方法前调用</span><br><span class="line">@property BOOL enableRate</span><br><span class="line">//播放速率 1.0为正常速率 0.5一半 2.0双倍速播放</span><br><span class="line">@property float rate</span><br><span class="line"></span><br><span class="line">//当前播放的时间点,可以实现定点进行播放</span><br><span class="line">@property NSTimeInterval currentTime;</span><br><span class="line"></span><br><span class="line">//输出设备播放音频的时间，注意:如果播放中被暂停此时间也会继续累加</span><br><span class="line">@property(readonly) NSTimeInterval deviceCurrentTime</span><br><span class="line"></span><br><span class="line">//设置音频播放循环次数 如果为0则不循环，如果小于0则无限循环，大于0则表示循环次数</span><br><span class="line">@property NSInteger numberOfLoops;</span><br><span class="line"></span><br><span class="line">//获取音频设置字典</span><br><span class="line">@property(readonly) NSDictionary&lt;NSString *, id&gt; *settings NS_AVAILABLE(10_7, 4_0); /* returns a settings dictionary with keys as described in AVAudioSettings.h */</span><br><span class="line"></span><br><span class="line">/* returns the format of the audio data */</span><br><span class="line">@property(readonly) AVAudioFormat *format NS_AVAILABLE(10_12, 10_0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//是否开启仪表计数功能(启用音频测量) 默认为NO，一旦启用音频测量可以通过updateMeters方法更新测量值</span><br><span class="line">@property(getter=isMeteringEnabled) BOOL meteringEnabled; /* turns level metering on or off. default is off. */</span><br><span class="line"></span><br><span class="line">//更新仪表计数的值</span><br><span class="line">- (void)updateMeters; /* call to refresh meter values */</span><br><span class="line"></span><br><span class="line">//获得指定声道的分贝峰值，如果要获得分贝峰值必须在此之前调用updateMeters方法</span><br><span class="line">- (float)peakPowerForChannel:(NSUInteger)channelNumber; /* returns peak power in decibels for a given channel */</span><br><span class="line"></span><br><span class="line">//获得指定声道的分贝平均值，注意如果要获得分贝平均值必须在此之前调用updateMeters方法</span><br><span class="line">- (float)averagePowerForChannel:(NSUInteger)channelNumber; /* returns average power in decibels for a given channel */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* The channels property lets you assign the output to play to specific channels as described by AVAudioSession&apos;s channels property */</span><br><span class="line">/* This property is nil valued until set. */</span><br><span class="line">/* The array must have the same number of channels as returned by the numberOfChannels property. */</span><br><span class="line">//获得或设置播放声道</span><br><span class="line">@property(nonatomic, copy, nullable) NSArray&lt;AVAudioSessionChannelDescription *&gt; *channelAssignments</span><br></pre></td></tr></table></figure>
<h4 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--音频播放结束后调用的函数 被中断停止播放并不会被调用--&gt; </span><br><span class="line">- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--播放遇到错误时调用的函数--&gt;</span><br><span class="line">- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)player error:(NSError * __nullable)error;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">音乐播放器被打断</span><br><span class="line"></span><br><span class="line">@param player .</span><br><span class="line">*/</span><br><span class="line">-(void)audioPlayerBeginInterruption:(AVAudioPlayer *)player&#123;</span><br><span class="line">NSLog(@&quot;播放被中断&quot;);</span><br><span class="line">//如果音频被中断，比如有电话呼入，该方法就会被回调，该方法可以保存当前播放信息，以便恢复继续播放的进度</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*  音乐播放器停止打断</span><br><span class="line">*</span><br><span class="line">*  @param player .</span><br><span class="line">*/</span><br><span class="line">-(void)audioPlayerEndInterruption:(AVAudioPlayer *)player</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;audioPlayerEndInterruption-停止打断&quot;);</span><br><span class="line">[player play];</span><br><span class="line">//继续播放</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后台播放"><a href="#后台播放" class="headerlink" title="后台播放"></a>后台播放</h3><p>1.需要添加info.plist<br><img src="/img/2017-04-07-Audio/1.png" alt="1" title="1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;UIBackgroundModes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;audio&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure>
<p>或者<br><img src="/img/2017-04-07-Audio/2.png" alt="2" title="2"><br>2.添加代码支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//设置锁屏仍能继续播放</span><br><span class="line">[[AVAudioSession sharedInstance] setCategory: AVAudioSessionCategoryPlayback error:nil];</span><br><span class="line">[[AVAudioSession sharedInstance] setActive: YES error: nil];</span><br></pre></td></tr></table></figure></p>
<h3 id="监听耳机事件"><a href="#监听耳机事件" class="headerlink" title="监听耳机事件"></a>监听耳机事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//添加通知，拔出耳机后暂停播放</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(routeChange:) name:AVAudioSessionRouteChangeNotification object:nil];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*  一旦输出改变则执行此方法</span><br><span class="line">*</span><br><span class="line">*  @param notification 输出改变通知对象</span><br><span class="line">*/</span><br><span class="line">-(void)routeChange:(NSNotification *)notification&#123;</span><br><span class="line"></span><br><span class="line">NSDictionary *dic=notification.userInfo;</span><br><span class="line">int changeReason= [dic[AVAudioSessionRouteChangeReasonKey] intValue];</span><br><span class="line"></span><br><span class="line">//等于AVAudioSessionRouteChangeReasonOldDeviceUnavailable表示旧输出不可用</span><br><span class="line">if (changeReason==AVAudioSessionRouteChangeReasonOldDeviceUnavailable) &#123;</span><br><span class="line">AVAudioSessionRouteDescription *routeDescription=dic[AVAudioSessionRouteChangePreviousRouteKey];</span><br><span class="line">AVAudioSessionPortDescription *portDescription= [routeDescription.outputs firstObject];</span><br><span class="line">//原设备为耳机则暂停</span><br><span class="line">if ([portDescription.portType isEqualToString:@&quot;Headphones&quot;]) &#123;</span><br><span class="line">         [self.audioPlayer pause];</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后台播放信息显示"><a href="#后台播放信息显示" class="headerlink" title="后台播放信息显示"></a>后台播放信息显示</h3><p>1.导入框架 #import \&lt;MediaPlayer/MediaPlayer.h><br>2.添加代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *dict = [[NSMutableDictionary alloc] init];</span><br><span class="line">//设置歌曲题目</span><br><span class="line">[dict setObject:@&quot;题目&quot; forKey:MPMediaItemPropertyTitle];</span><br><span class="line">//设置歌手名</span><br><span class="line">[dict setObject:@&quot;歌手&quot; forKey:MPMediaItemPropertyArtist];</span><br><span class="line">//设置专辑名</span><br><span class="line">[dict setObject:@&quot;专辑&quot; forKey:MPMediaItemPropertyAlbumTitle];</span><br><span class="line">//设置显示的图片</span><br><span class="line">UIImage *newImage = [UIImage imageNamed:@&quot;43.png&quot;];</span><br><span class="line">[dict setObject:[[MPMediaItemArtwork alloc] initWithImage:newImage]</span><br><span class="line">forKey:MPMediaItemPropertyArtwork];</span><br><span class="line">//设置歌曲时长</span><br><span class="line">[dict setObject:[NSNumber numberWithDouble:300] forKey:MPMediaItemPropertyPlaybackDuration];</span><br><span class="line">//设置已经播放时长</span><br><span class="line">[dict setObject:[NSNumber numberWithDouble:150] forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime]; </span><br><span class="line">//更新字典</span><br><span class="line">[[MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:dict];</span><br></pre></td></tr></table></figure></p>
<p>注:实现后台播放显示歌词的方法实现思路:将歌词信息,绘制到专辑图片上进行显示</p>
<h3 id="后台播放远程控制"><a href="#后台播放远程控制" class="headerlink" title="后台播放远程控制"></a>后台播放远程控制</h3><p>1.注册接受远程控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">//    接受远程控制</span><br><span class="line">[self becomeFirstResponder];</span><br><span class="line">[[UIApplication sharedApplication] beginReceivingRemoteControlEvents];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">//    取消远程控制</span><br><span class="line">[self resignFirstResponder];</span><br><span class="line">[[UIApplication sharedApplication] endReceivingRemoteControlEvents];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.实现监听方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)remoteControlReceivedWithEvent:(UIEvent *)event &#123;</span><br><span class="line">if (event.type == UIEventTypeRemoteControl) &#123;</span><br><span class="line">//判断是否为远程控制</span><br><span class="line">switch (event.subtype) &#123;</span><br><span class="line">//播放</span><br><span class="line">case  UIEventSubtypeRemoteControlPlay:</span><br><span class="line">if (![self.audioPlayer isPlaying]) &#123;</span><br><span class="line">[self.audioPlayer play];</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">case UIEventSubtypeRemoteControlPause:</span><br><span class="line">//暂停</span><br><span class="line">if ([self.audioPlayer isPlaying]) &#123;</span><br><span class="line">[self.audioPlayer pause];</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">case UIEventSubtypeRemoteControlNextTrack:</span><br><span class="line">NSLog(@&quot;下一首&quot;);</span><br><span class="line">break;</span><br><span class="line">case UIEventSubtypeRemoteControlPreviousTrack:</span><br><span class="line">NSLog(@&quot;上一首 &quot;);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注:<br>event是事件类型对象,type是事件类型枚举<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIEventType) &#123;</span><br><span class="line">UIEventTypeTouches, //触摸事件</span><br><span class="line">UIEventTypeMotion,  //运动事件</span><br><span class="line">UIEventTypeRemoteControl, // 远程控制事件</span><br><span class="line">UIEventTypePresses NS_ENUM_AVAILABLE_IOS(9_0),//物理按钮事件类型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>subtype中的枚举便是点击这些控制键后传递给我们的消息，我们可以根据这些消息在app内做逻辑处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIEventSubtype) &#123;</span><br><span class="line">// available in iPhone OS 3.0</span><br><span class="line">UIEventSubtypeNone                              = 0,</span><br><span class="line">// for UIEventTypeMotion, available in iPhone OS 3.0</span><br><span class="line">//摇晃</span><br><span class="line">UIEventSubtypeMotionShake                       = 1,</span><br><span class="line">//UIEventTypeRemoteControl相关的枚举信息</span><br><span class="line">// for UIEventTypeRemoteControl, available in iOS 4.0</span><br><span class="line">//点击播放按钮或者耳机线控中间那个按钮</span><br><span class="line">UIEventSubtypeRemoteControlPlay                 = 100,</span><br><span class="line">//点击暂停按钮</span><br><span class="line">UIEventSubtypeRemoteControlPause                = 101,</span><br><span class="line">//点击停止按钮</span><br><span class="line">UIEventSubtypeRemoteControlStop                 = 102,</span><br><span class="line">//点击播放与暂停开关按钮(iphone抽屉中使用这个)</span><br><span class="line">UIEventSubtypeRemoteControlTogglePlayPause      = 103,</span><br><span class="line">//点击下一曲按钮或者耳机中间按钮两下</span><br><span class="line">UIEventSubtypeRemoteControlNextTrack            = 104,</span><br><span class="line">//点击上一曲按钮或者耳机中间按钮三下</span><br><span class="line">UIEventSubtypeRemoteControlPreviousTrack        = 105,</span><br><span class="line">//快退开始 点击耳机中间按钮三下不放开</span><br><span class="line">UIEventSubtypeRemoteControlBeginSeekingBackward = 106,</span><br><span class="line">//快退结束 耳机快退控制松开后</span><br><span class="line">UIEventSubtypeRemoteControlEndSeekingBackward   = 107,</span><br><span class="line">//开始快进 耳机中间按钮两下不放开</span><br><span class="line">UIEventSubtypeRemoteControlBeginSeekingForward  = 108,</span><br><span class="line">//快进结束 耳机快进操作松开后</span><br><span class="line">UIEventSubtypeRemoteControlEndSeekingForward    = 109,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="拓展-后台播放远程控制的相关自定义"><a href="#拓展-后台播放远程控制的相关自定义" class="headerlink" title="拓展:后台播放远程控制的相关自定义"></a>拓展:后台播放远程控制的相关自定义</h3><p>MPRemoteCommandCenter属于\&lt;MediaPlayer/MediaPlayer.h>框架,是一个单例类,处理远程控制中心事件<br>可以自定义你的控制中心,锁屏时控制,siri语音控制.它管理一系列命令Playback Commands,Feedback Command,Previous/Next Track Commands),Skip Interval Commands,Seek Command等<br>MPRemoteCommand是这些所有命令的父类<br>下面简单介绍:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//是否开启命令</span><br><span class="line">@property (nonatomic, assign, getter = isEnabled) BOOL enabled;</span><br><span class="line"></span><br><span class="line">//Target-action 添加事件处理</span><br><span class="line">- (void)addTarget:(id)target action:(SEL)action;</span><br><span class="line">//当属性enable = NO时,移除</span><br><span class="line">- (void)removeTarget:(id)target action:(nullable SEL)action;</span><br><span class="line">- (void)removeTarget:(nullable id)target;</span><br><span class="line"></span><br><span class="line">//返回一个事件对象 MPRemoteCommandEvent是一个命令事件的父类,对应不同的命令进行了继承扩展,主要添加一些属性,比如拖拽音乐进度的positionTime</span><br><span class="line">- (id)addTargetWithHandler:(MPRemoteCommandHandlerStatus(^)(MPRemoteCommandEvent *event))handler;</span><br></pre></td></tr></table></figure></p>
<p>远程控制三部曲</p>
<p>1:监听远程控制事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)beginReceivingRemoteControlEvents</span><br></pre></td></tr></table></figure></p>
<p>2:捕获远程控制事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)remoteControlReceivedWithEvent:(UIEvent *)event</span><br></pre></td></tr></table></figure></p>
<p>3.取消远程控制事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)endReceivingRemoteControlEvents</span><br></pre></td></tr></table></figure></p>
<h4 id="网易云的锁屏实现"><a href="#网易云的锁屏实现" class="headerlink" title="网易云的锁屏实现"></a>网易云的锁屏实现</h4><p>注:添加的RemoteComand必须设置Enable为YES,并添加Target才会显示,并且添加相同类型RemoteComand,有优先级的选择显示,更改原有默认显示的上一曲,播放/暂停,下一曲会失效,需要重新添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MPRemoteCommandCenter *rcc = [MPRemoteCommandCenter sharedCommandCenter];</span><br><span class="line"></span><br><span class="line">//feedBack</span><br><span class="line">[rcc.likeCommand setEnabled:YES];</span><br><span class="line">//使用block</span><br><span class="line">[rcc.likeCommand addTargetWithHandler:^MPRemoteCommandHandlerStatus(MPRemoteCommandEvent * _Nonnull event) &#123;</span><br><span class="line">NSLog(@&quot;like!&quot;);</span><br><span class="line">return MPRemoteCommandHandlerStatusSuccess;</span><br><span class="line">&#125;];</span><br><span class="line">rcc.likeCommand.localizedTitle = @&quot;喜欢&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[rcc.dislikeCommand setEnabled:YES];</span><br><span class="line">//使用target-action 不喜欢</span><br><span class="line">[rcc.dislikeCommand addTarget:self action:@selector(previousCommandAction)];</span><br><span class="line">rcc.dislikeCommand.localizedTitle = @&quot;上一首&quot;;</span><br><span class="line">[rcc.bookmarkCommand setEnabled:YES];</span><br><span class="line">//取消Action</span><br><span class="line">//    [rcc.dislikeCommand removeTarget:self action:@selector(previousCommandAction)];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//书签</span><br><span class="line">[rcc.bookmarkCommand addTargetWithHandler:^MPRemoteCommandHandlerStatus(MPRemoteCommandEvent * _Nonnull event) &#123;</span><br><span class="line">NSLog(@&quot;bookmark&quot;);</span><br><span class="line">return MPRemoteCommandHandlerStatusSuccess;</span><br><span class="line">&#125;];</span><br><span class="line">rcc.bookmarkCommand.localizedTitle = @&quot;收藏&quot;;</span><br></pre></td></tr></table></figure>
<p>效果图:<br><img src="/img/2017-04-07-Audio/3.jpg" alt="3" title="3"></p>
<h4 id="锁屏控制播放进度"><a href="#锁屏控制播放进度" class="headerlink" title="锁屏控制播放进度"></a>锁屏控制播放进度</h4><p>主要使用:MPChangePlaybackPositionCommand<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//改变音乐播放进度</span><br><span class="line">MPChangePlaybackPositionCommand *changePlayBackPosition = [rcc changePlaybackPositionCommand];</span><br><span class="line">[changePlayBackPosition setEnabled:YES];</span><br><span class="line">[changePlayBackPosition addTargetWithHandler:^MPRemoteCommandHandlerStatus(MPRemoteCommandEvent * _Nonnull event) &#123;</span><br><span class="line">MPChangePlaybackPositionCommandEvent *events = (MPChangePlaybackPositionCommandEvent *)event;</span><br><span class="line">self.audioPlayer.currentTime = events.positionTime;</span><br><span class="line">return MPRemoteCommandHandlerStatusSuccess;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<h3 id="流式音频播放-播放网络音频"><a href="#流式音频播放-播放网络音频" class="headerlink" title="流式音频播放(播放网络音频)"></a>流式音频播放(播放网络音频)</h3><p>使用AudioToolbox框架中的音频队列服务Audio Queue Services。<br>第三方框架:FreeStreamer</p>
<p>#import “FSAudioStream.h”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">FSAudioStream *player = [[FSAudioStream alloc]initWithUrl:[self getFileUrl]];</span><br><span class="line">player.onFailure = ^(FSAudioStreamError error, NSString *errorDescription) &#123;</span><br><span class="line">NSLog(@&quot;播放错误error:%@&quot;,errorDescription);</span><br><span class="line">&#125;;</span><br><span class="line">player.onCompletion = ^&#123;</span><br><span class="line">NSLog(@&quot;播放完成&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">//设置音量</span><br><span class="line">[player setVolume:0.5];</span><br><span class="line">//播放</span><br><span class="line">[player play];</span><br><span class="line"></span><br><span class="line">//添加引用</span><br><span class="line">self.audioStream = player;</span><br></pre></td></tr></table></figure></p>
<p>豆瓣:DOUAudioStreamer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;DOUAudioStreamer.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface AudioModel : NSObject&lt;DOUAudioFile&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSURL *audioFileURL;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AudioModel</span><br><span class="line"></span><br><span class="line">- (NSURL *)audioFileURL&#123;</span><br><span class="line">NSString *urlStr= @&quot;http://sc1.111ttt.com/2017/1/03/07/296072048390.mp3&quot;;</span><br><span class="line">NSURL *url=[NSURL URLWithString:urlStr];</span><br><span class="line">self.audioFileURL = url;</span><br><span class="line">return url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">AudioModel *file = [[AudioModel alloc]init];</span><br><span class="line">[file audioFileURL];</span><br><span class="line">self.stream = [[DOUAudioStreamer alloc]initWithAudioFile:file];</span><br><span class="line">[self.stream play];</span><br></pre></td></tr></table></figure></p>
<p>参考:<br><a href="https://developer.apple.com/library/content/samplecode/MPRemoteCommandSample/Introduction/Intro.html" target="_blank" rel="noopener">https://developer.apple.com/library/content/samplecode/MPRemoteCommandSample/Introduction/Intro.html</a> </p>




    </div>










    <footer class="post-footer">








        <div class="post-eof"></div>

    </footer>
  </div>



  </article>











  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">



  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/07/2017-04-07-Audio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="立志当大神">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rhino">
    </span>


      <header class="post-header">



          <h1 class="post-title" itemprop="name headline">

                <a class="post-title-link" href="/2017/04/07/2017-04-07-Audio/" itemprop="url">音频初见</a></h1>


        <div class="post-meta">
          <span class="post-time">

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

                <span class="post-meta-item-text">Posted on</span>

              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-07T00:00:00+08:00">
                2017-04-07
              </time>





          </span>
















        </div>
      </header>





    <div class="post-body" itemprop="articleBody">







            <h1 id="音频初见"><a href="#音频初见" class="headerlink" title="音频初见"></a>音频初见</h1><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>音频: 从形式上分为<br>短音频(音效播放):不需要进度|循环等控制  AudioToolbox.framework<br>(C语言框架 </p>
<ul>
<li>本质:将音频注册到system sound service(简单底层的声音播放服务))<br>特点:</li>
<li>播放时间不超过30s</li>
<li>数据格式PCM/IMA4</li>
<li>音频文件必须打包成.caf,.aif,.wav,(.MP3也可以)</li>
</ul>
<p>长音频(音乐播放) </p>
<ul>
<li>较大的音频文件,需要进行精确的控制的场景     </li>
<li>AVFoundation.framework</li>
<li>支持的音频格式有:AAC,ALAC,HE-AAC,iLBC,IMA4,MP3等.</li>
</ul>
<h3 id="音效播放"><a href="#音效播放" class="headerlink" title="音效播放"></a>音效播放</h3><p>步骤:</p>
<ul>
<li>不要忘记导入头文件: #import \&lt;AudioToolbox/AudioToolbox.h></li>
<li>1.调用AudioServicesCreateSystemSoundID(CFURLRef  inFileURL, SystemSoundID*   outSystemSoundID)函数获得系统声音ID。</li>
<li>2.如果需要监听播放完成操作，则使用AudioServicesAddSystemSoundCompletion(  SystemSoundID inSystemSoundID,CFRunLoopRef  inRunLoop, CFStringRef  inRunLoopMode, AudioServicesSystemSoundCompletionProc  inCompletionRoutine, void*  inClientData)方法注册回调函数。</li>
<li>3.调用AudioServicesPlaySystemSound(SystemSoundID inSystemSoundID)<br>  AudioServicesPlayAlertSound(SystemSoundID inSystemSoundID) 方法播放音效（后者带有震动效果）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (void)audioBox&#123;</span><br><span class="line"></span><br><span class="line">//获取资源路径</span><br><span class="line">NSString *pathSource = [[NSBundle mainBundle]pathForResource:@&quot;audiobox&quot; ofType:@&quot;.caf&quot;];</span><br><span class="line">NSURL *sourceUrl = [NSURL fileURLWithPath:pathSource];</span><br><span class="line"></span><br><span class="line">//系统声音id</span><br><span class="line">SystemSoundID soundID =  0;</span><br><span class="line">/**</span><br><span class="line">注册音效服务</span><br><span class="line"></span><br><span class="line">@param inFileURL#&gt; 音频文件URL 需要桥接-&gt;C语言</span><br><span class="line">@param outSystemSoundID#&gt; 输出音效ID</span><br><span class="line">@return 将音效文件加入到系统音频服务中并返回一个长整型音频ID</span><br><span class="line">*/</span><br><span class="line">AudioServicesCreateSystemSoundID((__bridge CFURLRef)(sourceUrl), &amp;soundID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">添加播放完毕回调函数</span><br><span class="line"></span><br><span class="line">@param inSystemSoundID#&gt; 音效ID</span><br><span class="line">@param inRunLoop#&gt; 添加到Runloop</span><br><span class="line">@param inRunLoopMode#&gt; RunloopMode</span><br><span class="line">@param inCompletionRoutine#&gt; 回调函数</span><br><span class="line">@param inClientData#&gt; 传递给回调函数的相关数据</span><br><span class="line">@return ..</span><br><span class="line">*/</span><br><span class="line">AudioServicesAddSystemSoundCompletion(soundID, NULL, NULL, playCompletion, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//播放</span><br><span class="line">AudioServicesPlayAlertSound(soundID); //播放音效并震动</span><br><span class="line">//    AudioServicesPlaySystemSound(soundID); //播放音效</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">回调函数</span><br><span class="line"></span><br><span class="line">@param ssID 音效id</span><br><span class="line">@param clientData 回调时传递的数据</span><br><span class="line">*/</span><br><span class="line">void playCompletion(SystemSoundID ssID, void* __nullable clientData)&#123;</span><br><span class="line">NSLog(@&quot;播放完成&quot;);</span><br><span class="line">//摧毁音效</span><br><span class="line">AudioServicesDisposeSystemSoundID(ssID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="音乐播放-AVAudioPlayer"><a href="#音乐播放-AVAudioPlayer" class="headerlink" title="音乐播放 AVAudioPlayer"></a>音乐播放 AVAudioPlayer</h3><p>AVAudioPlayer支持多种音频格式,而且能够对进度,音量,播放速度等控制<br>头文件 #import \&lt;AVFoundation/AVFoundation.h><br>步骤:</p>
<ul>
<li>1.给定资源路径,或者二进制数据初始化播放器</li>
<li>2.设置相关属性</li>
<li>3.执行播放,更新相关UI(进度更新,歌词显示(CADislinkplay/NSTimer))</li>
</ul>
<h4 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h4><p>AVAudioPlayer可以接受本地资源路径(NSURL)/NSData类型数据(可以用来加载网络链接),但是实质上AVAudioPlayer不支持流式播放,只能播放完整的文件,使用后者加载网络链接,当播放的音频文件较大或者网络不好就需要过长的时间等待<br>每一个实例化方法返回一个AVAudioPlayer对象,每一个文件/Data对应一个AVAudioPlayer对象,传入一个NSError的指针,用于判断初始化是否成功.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable instancetype)initWithContentsOfURL:(NSURL *)url error:(NSError **)outError;</span><br><span class="line">- (nullable instancetype)initWithData:(NSData *)data error:(NSError **)outError;</span><br></pre></td></tr></table></figure>
<h4 id="播放控制相关API"><a href="#播放控制相关API" class="headerlink" title="播放控制相关API"></a>播放控制相关API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//准备播放,分配播放所需的资源，并将其加入内部播放队列,加载音频文件到缓冲区，注意:即使在播放之前音频文件没有加载到缓冲区程序也会隐式调用此方法。</span><br><span class="line">- (BOOL)prepareToPlay;</span><br><span class="line">//播放,如果资源还没准备好,会隐式调用prepareToPlay方法,是异步的</span><br><span class="line">- (BOOL)play;</span><br><span class="line">//相对当前设备时间或指定的时间开始播放音频</span><br><span class="line">- (BOOL)playAtTime:(NSTimeInterval)time </span><br><span class="line"></span><br><span class="line">NSTimeInterval nowTime = self.audioPlayer.deviceCurrentTime;</span><br><span class="line">[self.audioPlayer playAtTime:nowTime + 2.0];</span><br><span class="line"></span><br><span class="line">//暂停播放 并且准备好继续播放</span><br><span class="line">- (void)pause;          /* pauses playback, but remains ready to play. */</span><br><span class="line">//停止播放 不再准备好继续播放,再次调用会重新开始播放</span><br><span class="line">- (void)stop;           /* stops playback. no longer ready to play. */</span><br></pre></td></tr></table></figure>
<h4 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//获取是否正在播放</span><br><span class="line">@property(readonly, getter=isPlaying) BOOL playing;</span><br><span class="line">//获取当前音频声道数</span><br><span class="line">@property(readonly) NSUInteger numberOfChannels;</span><br><span class="line">//获取当前音频时长</span><br><span class="line">@property(readonly) NSTimeInterval duration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取创建时的音频路径 跟初始化方法相关联</span><br><span class="line">@property(readonly, nullable) NSURL *url;</span><br><span class="line">//获取创建时的音频数据 跟初始化方法相关联</span><br><span class="line">@property(readonly, nullable) NSData *data;</span><br><span class="line">//声道 -1.0~0.0左声道 0.0临界值 0.0~1.0为右声道</span><br><span class="line">@property float pan</span><br><span class="line">//音量 正常范围在0.0~1.0</span><br><span class="line">@property float volume;</span><br><span class="line">- (void)setVolume:(float)volume fadeDuration:(NSTimeInterval)duration NS_AVAILABLE(10_12, 10_0); /* fade to a new volume over a duration */</span><br><span class="line"></span><br><span class="line">//是否可以改变播放速率 必须在prepareToPlay方法前调用</span><br><span class="line">@property BOOL enableRate</span><br><span class="line">//播放速率 1.0为正常速率 0.5一半 2.0双倍速播放</span><br><span class="line">@property float rate</span><br><span class="line"></span><br><span class="line">//当前播放的时间点,可以实现定点进行播放</span><br><span class="line">@property NSTimeInterval currentTime;</span><br><span class="line"></span><br><span class="line">//输出设备播放音频的时间，注意:如果播放中被暂停此时间也会继续累加</span><br><span class="line">@property(readonly) NSTimeInterval deviceCurrentTime</span><br><span class="line"></span><br><span class="line">//设置音频播放循环次数 如果为0则不循环，如果小于0则无限循环，大于0则表示循环次数</span><br><span class="line">@property NSInteger numberOfLoops;</span><br><span class="line"></span><br><span class="line">//获取音频设置字典</span><br><span class="line">@property(readonly) NSDictionary&lt;NSString *, id&gt; *settings NS_AVAILABLE(10_7, 4_0); /* returns a settings dictionary with keys as described in AVAudioSettings.h */</span><br><span class="line"></span><br><span class="line">/* returns the format of the audio data */</span><br><span class="line">@property(readonly) AVAudioFormat *format NS_AVAILABLE(10_12, 10_0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//是否开启仪表计数功能(启用音频测量) 默认为NO，一旦启用音频测量可以通过updateMeters方法更新测量值</span><br><span class="line">@property(getter=isMeteringEnabled) BOOL meteringEnabled; /* turns level metering on or off. default is off. */</span><br><span class="line"></span><br><span class="line">//更新仪表计数的值</span><br><span class="line">- (void)updateMeters; /* call to refresh meter values */</span><br><span class="line"></span><br><span class="line">//获得指定声道的分贝峰值，如果要获得分贝峰值必须在此之前调用updateMeters方法</span><br><span class="line">- (float)peakPowerForChannel:(NSUInteger)channelNumber; /* returns peak power in decibels for a given channel */</span><br><span class="line"></span><br><span class="line">//获得指定声道的分贝平均值，注意如果要获得分贝平均值必须在此之前调用updateMeters方法</span><br><span class="line">- (float)averagePowerForChannel:(NSUInteger)channelNumber; /* returns average power in decibels for a given channel */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* The channels property lets you assign the output to play to specific channels as described by AVAudioSession&apos;s channels property */</span><br><span class="line">/* This property is nil valued until set. */</span><br><span class="line">/* The array must have the same number of channels as returned by the numberOfChannels property. */</span><br><span class="line">//获得或设置播放声道</span><br><span class="line">@property(nonatomic, copy, nullable) NSArray&lt;AVAudioSessionChannelDescription *&gt; *channelAssignments</span><br></pre></td></tr></table></figure>
<h4 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--音频播放结束后调用的函数 被中断停止播放并不会被调用--&gt; </span><br><span class="line">- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--播放遇到错误时调用的函数--&gt;</span><br><span class="line">- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)player error:(NSError * __nullable)error;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">音乐播放器被打断</span><br><span class="line"></span><br><span class="line">@param player .</span><br><span class="line">*/</span><br><span class="line">-(void)audioPlayerBeginInterruption:(AVAudioPlayer *)player&#123;</span><br><span class="line">NSLog(@&quot;播放被中断&quot;);</span><br><span class="line">//如果音频被中断，比如有电话呼入，该方法就会被回调，该方法可以保存当前播放信息，以便恢复继续播放的进度</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*  音乐播放器停止打断</span><br><span class="line">*</span><br><span class="line">*  @param player .</span><br><span class="line">*/</span><br><span class="line">-(void)audioPlayerEndInterruption:(AVAudioPlayer *)player</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;audioPlayerEndInterruption-停止打断&quot;);</span><br><span class="line">[player play];</span><br><span class="line">//继续播放</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后台播放"><a href="#后台播放" class="headerlink" title="后台播放"></a>后台播放</h3><p>1.需要添加info.plist<br><img src="/img/2017-04-07-Audio/1.png" alt="1" title="1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;UIBackgroundModes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;string&gt;audio&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure>
<p>或者<br><img src="/img/2017-04-07-Audio/2.png" alt="2" title="2"><br>2.添加代码支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//设置锁屏仍能继续播放</span><br><span class="line">[[AVAudioSession sharedInstance] setCategory: AVAudioSessionCategoryPlayback error:nil];</span><br><span class="line">[[AVAudioSession sharedInstance] setActive: YES error: nil];</span><br></pre></td></tr></table></figure></p>
<h3 id="监听耳机事件"><a href="#监听耳机事件" class="headerlink" title="监听耳机事件"></a>监听耳机事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//添加通知，拔出耳机后暂停播放</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(routeChange:) name:AVAudioSessionRouteChangeNotification object:nil];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*  一旦输出改变则执行此方法</span><br><span class="line">*</span><br><span class="line">*  @param notification 输出改变通知对象</span><br><span class="line">*/</span><br><span class="line">-(void)routeChange:(NSNotification *)notification&#123;</span><br><span class="line"></span><br><span class="line">NSDictionary *dic=notification.userInfo;</span><br><span class="line">int changeReason= [dic[AVAudioSessionRouteChangeReasonKey] intValue];</span><br><span class="line"></span><br><span class="line">//等于AVAudioSessionRouteChangeReasonOldDeviceUnavailable表示旧输出不可用</span><br><span class="line">if (changeReason==AVAudioSessionRouteChangeReasonOldDeviceUnavailable) &#123;</span><br><span class="line">AVAudioSessionRouteDescription *routeDescription=dic[AVAudioSessionRouteChangePreviousRouteKey];</span><br><span class="line">AVAudioSessionPortDescription *portDescription= [routeDescription.outputs firstObject];</span><br><span class="line">//原设备为耳机则暂停</span><br><span class="line">if ([portDescription.portType isEqualToString:@&quot;Headphones&quot;]) &#123;</span><br><span class="line">         [self.audioPlayer pause];</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后台播放信息显示"><a href="#后台播放信息显示" class="headerlink" title="后台播放信息显示"></a>后台播放信息显示</h3><p>1.导入框架 #import \&lt;MediaPlayer/MediaPlayer.h><br>2.添加代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *dict = [[NSMutableDictionary alloc] init];</span><br><span class="line">//设置歌曲题目</span><br><span class="line">[dict setObject:@&quot;题目&quot; forKey:MPMediaItemPropertyTitle];</span><br><span class="line">//设置歌手名</span><br><span class="line">[dict setObject:@&quot;歌手&quot; forKey:MPMediaItemPropertyArtist];</span><br><span class="line">//设置专辑名</span><br><span class="line">[dict setObject:@&quot;专辑&quot; forKey:MPMediaItemPropertyAlbumTitle];</span><br><span class="line">//设置显示的图片</span><br><span class="line">UIImage *newImage = [UIImage imageNamed:@&quot;43.png&quot;];</span><br><span class="line">[dict setObject:[[MPMediaItemArtwork alloc] initWithImage:newImage]</span><br><span class="line">forKey:MPMediaItemPropertyArtwork];</span><br><span class="line">//设置歌曲时长</span><br><span class="line">[dict setObject:[NSNumber numberWithDouble:300] forKey:MPMediaItemPropertyPlaybackDuration];</span><br><span class="line">//设置已经播放时长</span><br><span class="line">[dict setObject:[NSNumber numberWithDouble:150] forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime]; </span><br><span class="line">//更新字典</span><br><span class="line">[[MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:dict];</span><br></pre></td></tr></table></figure></p>
<p>注:实现后台播放显示歌词的方法实现思路:将歌词信息,绘制到专辑图片上进行显示</p>
<h3 id="后台播放远程控制"><a href="#后台播放远程控制" class="headerlink" title="后台播放远程控制"></a>后台播放远程控制</h3><p>1.注册接受远程控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">//    接受远程控制</span><br><span class="line">[self becomeFirstResponder];</span><br><span class="line">[[UIApplication sharedApplication] beginReceivingRemoteControlEvents];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">//    取消远程控制</span><br><span class="line">[self resignFirstResponder];</span><br><span class="line">[[UIApplication sharedApplication] endReceivingRemoteControlEvents];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.实现监听方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)remoteControlReceivedWithEvent:(UIEvent *)event &#123;</span><br><span class="line">if (event.type == UIEventTypeRemoteControl) &#123;</span><br><span class="line">//判断是否为远程控制</span><br><span class="line">switch (event.subtype) &#123;</span><br><span class="line">//播放</span><br><span class="line">case  UIEventSubtypeRemoteControlPlay:</span><br><span class="line">if (![self.audioPlayer isPlaying]) &#123;</span><br><span class="line">[self.audioPlayer play];</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">case UIEventSubtypeRemoteControlPause:</span><br><span class="line">//暂停</span><br><span class="line">if ([self.audioPlayer isPlaying]) &#123;</span><br><span class="line">[self.audioPlayer pause];</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">case UIEventSubtypeRemoteControlNextTrack:</span><br><span class="line">NSLog(@&quot;下一首&quot;);</span><br><span class="line">break;</span><br><span class="line">case UIEventSubtypeRemoteControlPreviousTrack:</span><br><span class="line">NSLog(@&quot;上一首 &quot;);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注:<br>event是事件类型对象,type是事件类型枚举<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIEventType) &#123;</span><br><span class="line">UIEventTypeTouches, //触摸事件</span><br><span class="line">UIEventTypeMotion,  //运动事件</span><br><span class="line">UIEventTypeRemoteControl, // 远程控制事件</span><br><span class="line">UIEventTypePresses NS_ENUM_AVAILABLE_IOS(9_0),//物理按钮事件类型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>subtype中的枚举便是点击这些控制键后传递给我们的消息，我们可以根据这些消息在app内做逻辑处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIEventSubtype) &#123;</span><br><span class="line">// available in iPhone OS 3.0</span><br><span class="line">UIEventSubtypeNone                              = 0,</span><br><span class="line">// for UIEventTypeMotion, available in iPhone OS 3.0</span><br><span class="line">//摇晃</span><br><span class="line">UIEventSubtypeMotionShake                       = 1,</span><br><span class="line">//UIEventTypeRemoteControl相关的枚举信息</span><br><span class="line">// for UIEventTypeRemoteControl, available in iOS 4.0</span><br><span class="line">//点击播放按钮或者耳机线控中间那个按钮</span><br><span class="line">UIEventSubtypeRemoteControlPlay                 = 100,</span><br><span class="line">//点击暂停按钮</span><br><span class="line">UIEventSubtypeRemoteControlPause                = 101,</span><br><span class="line">//点击停止按钮</span><br><span class="line">UIEventSubtypeRemoteControlStop                 = 102,</span><br><span class="line">//点击播放与暂停开关按钮(iphone抽屉中使用这个)</span><br><span class="line">UIEventSubtypeRemoteControlTogglePlayPause      = 103,</span><br><span class="line">//点击下一曲按钮或者耳机中间按钮两下</span><br><span class="line">UIEventSubtypeRemoteControlNextTrack            = 104,</span><br><span class="line">//点击上一曲按钮或者耳机中间按钮三下</span><br><span class="line">UIEventSubtypeRemoteControlPreviousTrack        = 105,</span><br><span class="line">//快退开始 点击耳机中间按钮三下不放开</span><br><span class="line">UIEventSubtypeRemoteControlBeginSeekingBackward = 106,</span><br><span class="line">//快退结束 耳机快退控制松开后</span><br><span class="line">UIEventSubtypeRemoteControlEndSeekingBackward   = 107,</span><br><span class="line">//开始快进 耳机中间按钮两下不放开</span><br><span class="line">UIEventSubtypeRemoteControlBeginSeekingForward  = 108,</span><br><span class="line">//快进结束 耳机快进操作松开后</span><br><span class="line">UIEventSubtypeRemoteControlEndSeekingForward    = 109,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="拓展-后台播放远程控制的相关自定义"><a href="#拓展-后台播放远程控制的相关自定义" class="headerlink" title="拓展:后台播放远程控制的相关自定义"></a>拓展:后台播放远程控制的相关自定义</h3><p>MPRemoteCommandCenter属于\&lt;MediaPlayer/MediaPlayer.h>框架,是一个单例类,处理远程控制中心事件<br>可以自定义你的控制中心,锁屏时控制,siri语音控制.它管理一系列命令Playback Commands,Feedback Command,Previous/Next Track Commands),Skip Interval Commands,Seek Command等<br>MPRemoteCommand是这些所有命令的父类<br>下面简单介绍:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//是否开启命令</span><br><span class="line">@property (nonatomic, assign, getter = isEnabled) BOOL enabled;</span><br><span class="line"></span><br><span class="line">//Target-action 添加事件处理</span><br><span class="line">- (void)addTarget:(id)target action:(SEL)action;</span><br><span class="line">//当属性enable = NO时,移除</span><br><span class="line">- (void)removeTarget:(id)target action:(nullable SEL)action;</span><br><span class="line">- (void)removeTarget:(nullable id)target;</span><br><span class="line"></span><br><span class="line">//返回一个事件对象 MPRemoteCommandEvent是一个命令事件的父类,对应不同的命令进行了继承扩展,主要添加一些属性,比如拖拽音乐进度的positionTime</span><br><span class="line">- (id)addTargetWithHandler:(MPRemoteCommandHandlerStatus(^)(MPRemoteCommandEvent *event))handler;</span><br></pre></td></tr></table></figure></p>
<p>远程控制三部曲</p>
<p>1:监听远程控制事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)beginReceivingRemoteControlEvents</span><br></pre></td></tr></table></figure></p>
<p>2:捕获远程控制事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)remoteControlReceivedWithEvent:(UIEvent *)event</span><br></pre></td></tr></table></figure></p>
<p>3.取消远程控制事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)endReceivingRemoteControlEvents</span><br></pre></td></tr></table></figure></p>
<h4 id="网易云的锁屏实现"><a href="#网易云的锁屏实现" class="headerlink" title="网易云的锁屏实现"></a>网易云的锁屏实现</h4><p>注:添加的RemoteComand必须设置Enable为YES,并添加Target才会显示,并且添加相同类型RemoteComand,有优先级的选择显示,更改原有默认显示的上一曲,播放/暂停,下一曲会失效,需要重新添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MPRemoteCommandCenter *rcc = [MPRemoteCommandCenter sharedCommandCenter];</span><br><span class="line"></span><br><span class="line">//feedBack</span><br><span class="line">[rcc.likeCommand setEnabled:YES];</span><br><span class="line">//使用block</span><br><span class="line">[rcc.likeCommand addTargetWithHandler:^MPRemoteCommandHandlerStatus(MPRemoteCommandEvent * _Nonnull event) &#123;</span><br><span class="line">NSLog(@&quot;like!&quot;);</span><br><span class="line">return MPRemoteCommandHandlerStatusSuccess;</span><br><span class="line">&#125;];</span><br><span class="line">rcc.likeCommand.localizedTitle = @&quot;喜欢&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[rcc.dislikeCommand setEnabled:YES];</span><br><span class="line">//使用target-action 不喜欢</span><br><span class="line">[rcc.dislikeCommand addTarget:self action:@selector(previousCommandAction)];</span><br><span class="line">rcc.dislikeCommand.localizedTitle = @&quot;上一首&quot;;</span><br><span class="line">[rcc.bookmarkCommand setEnabled:YES];</span><br><span class="line">//取消Action</span><br><span class="line">//    [rcc.dislikeCommand removeTarget:self action:@selector(previousCommandAction)];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//书签</span><br><span class="line">[rcc.bookmarkCommand addTargetWithHandler:^MPRemoteCommandHandlerStatus(MPRemoteCommandEvent * _Nonnull event) &#123;</span><br><span class="line">NSLog(@&quot;bookmark&quot;);</span><br><span class="line">return MPRemoteCommandHandlerStatusSuccess;</span><br><span class="line">&#125;];</span><br><span class="line">rcc.bookmarkCommand.localizedTitle = @&quot;收藏&quot;;</span><br></pre></td></tr></table></figure>
<p>效果图:<br><img src="/img/2017-04-07-Audio/3.jpg" alt="3" title="3"></p>
<h4 id="锁屏控制播放进度"><a href="#锁屏控制播放进度" class="headerlink" title="锁屏控制播放进度"></a>锁屏控制播放进度</h4><p>主要使用:MPChangePlaybackPositionCommand<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//改变音乐播放进度</span><br><span class="line">MPChangePlaybackPositionCommand *changePlayBackPosition = [rcc changePlaybackPositionCommand];</span><br><span class="line">[changePlayBackPosition setEnabled:YES];</span><br><span class="line">[changePlayBackPosition addTargetWithHandler:^MPRemoteCommandHandlerStatus(MPRemoteCommandEvent * _Nonnull event) &#123;</span><br><span class="line">MPChangePlaybackPositionCommandEvent *events = (MPChangePlaybackPositionCommandEvent *)event;</span><br><span class="line">self.audioPlayer.currentTime = events.positionTime;</span><br><span class="line">return MPRemoteCommandHandlerStatusSuccess;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<h3 id="流式音频播放-播放网络音频"><a href="#流式音频播放-播放网络音频" class="headerlink" title="流式音频播放(播放网络音频)"></a>流式音频播放(播放网络音频)</h3><p>使用AudioToolbox框架中的音频队列服务Audio Queue Services。<br>第三方框架:FreeStreamer</p>
<p>#import “FSAudioStream.h”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">FSAudioStream *player = [[FSAudioStream alloc]initWithUrl:[self getFileUrl]];</span><br><span class="line">player.onFailure = ^(FSAudioStreamError error, NSString *errorDescription) &#123;</span><br><span class="line">NSLog(@&quot;播放错误error:%@&quot;,errorDescription);</span><br><span class="line">&#125;;</span><br><span class="line">player.onCompletion = ^&#123;</span><br><span class="line">NSLog(@&quot;播放完成&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">//设置音量</span><br><span class="line">[player setVolume:0.5];</span><br><span class="line">//播放</span><br><span class="line">[player play];</span><br><span class="line"></span><br><span class="line">//添加引用</span><br><span class="line">self.audioStream = player;</span><br></pre></td></tr></table></figure></p>
<p>豆瓣:DOUAudioStreamer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;DOUAudioStreamer.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface AudioModel : NSObject&lt;DOUAudioFile&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSURL *audioFileURL;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AudioModel</span><br><span class="line"></span><br><span class="line">- (NSURL *)audioFileURL&#123;</span><br><span class="line">NSString *urlStr= @&quot;http://sc1.111ttt.com/2017/1/03/07/296072048390.mp3&quot;;</span><br><span class="line">NSURL *url=[NSURL URLWithString:urlStr];</span><br><span class="line">self.audioFileURL = url;</span><br><span class="line">return url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">AudioModel *file = [[AudioModel alloc]init];</span><br><span class="line">[file audioFileURL];</span><br><span class="line">self.stream = [[DOUAudioStreamer alloc]initWithAudioFile:file];</span><br><span class="line">[self.stream play];</span><br></pre></td></tr></table></figure></p>
<p>参考:<br><a href="https://developer.apple.com/library/content/samplecode/MPRemoteCommandSample/Introduction/Intro.html" target="_blank" rel="noopener">https://developer.apple.com/library/content/samplecode/MPRemoteCommandSample/Introduction/Intro.html</a> </p>




    </div>










    <footer class="post-footer">








        <div class="post-eof"></div>

    </footer>
  </div>



  </article>











  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">



  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/04/2017-04-04-Xcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="立志当大神">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rhino">
    </span>


      <header class="post-header">



          <h1 class="post-title" itemprop="name headline">

                <a class="post-title-link" href="/2017/04/04/2017-04-04-Xcode/" itemprop="url">菜鸟Xcode起航</a></h1>


        <div class="post-meta">
          <span class="post-time">

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

                <span class="post-meta-item-text">Posted on</span>

              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-04T00:00:00+08:00">
                2017-04-04
              </time>





          </span>
















        </div>
      </header>





    <div class="post-body" itemprop="articleBody">







            <p>#Xcode的快捷键</p>
<p>##Xcode的说明<br><img src="/img/Xcode/image1.png" alt="Xcode截图" title="文件筛选"></p>




    </div>










    <footer class="post-footer">








        <div class="post-eof"></div>

    </footer>
  </div>



  </article>











  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">



  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/24/2017-03-24-Window/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="立志当大神">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rhino">
    </span>


      <header class="post-header">



          <h1 class="post-title" itemprop="name headline">

                <a class="post-title-link" href="/2017/03/24/2017-03-24-Window/" itemprop="url">Window 对象</a></h1>


        <div class="post-meta">
          <span class="post-time">

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

                <span class="post-meta-item-text">Posted on</span>

              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-24T00:00:00+08:00">
                2017-03-24
              </time>





          </span>
















        </div>
      </header>





    <div class="post-body" itemprop="articleBody">







            <h1 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h1><p>核心对象:它是客户端JavaScript程序的全局对象</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="延迟调用setTimeout-间歇调用setInterval"><a href="#延迟调用setTimeout-间歇调用setInterval" class="headerlink" title="延迟调用setTimeout() 间歇调用setInterval()"></a>延迟调用setTimeout() 间歇调用setInterval()</h3><blockquote>
<p>单词interval:间隔,间歇,空隙;差距,差别,隔阂<br><br>at invervals 每隔一定的时间或距离,不时;到处<br><br>in the intervals 不一会儿,不久<br></p>
</blockquote>
<ol>
<li>setTimeout()指定时间(毫秒)之后单次调用传入的函数,setInterval()指定毫秒数的间隔里重复调用传入的函数</li>
<li>同为全局函数,window对象的方法</li>
<li>返回值可以传递给clearTimeout(),clearInterval()用于取消函数的执行</li>
<li>参数,第一个参数为调用的函数(也可以传入一个字符串,但是实质为求值,执行eval());第二个参数为毫秒数,表示时间(传入的方法执行需要的时间间隔)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟调用</span></span><br><span class="line"><span class="keyword">var</span> funcTimeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//不建议使用字符串的方式调用</span></span><br><span class="line">setTimeout(<span class="string">"console.log('Hello world')"</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消延迟函数的执行</span></span><br><span class="line">clearTimeout(funcTimeout);</span><br><span class="line"></span><br><span class="line"><span class="comment">//间隔调用 定义一个间隔执行一定次数的方法</span></span><br><span class="line"><span class="keyword">var</span> maxCount = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> func = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">count ++;</span><br><span class="line"><span class="comment">////取消间隔调用</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br><span class="line">clearInterval(func);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello Rhino'</span> + count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//间隔执行</span></span><br><span class="line">func = setInterval(inter,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><img src="http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg" alt="Xcode" title="美丽花儿"></p>




    </div>










    <footer class="post-footer">








        <div class="post-eof"></div>

    </footer>
  </div>



  </article>











  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">



  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/22/2017-03-22-Object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="立志当大神">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rhino">
    </span>


      <header class="post-header">



          <h1 class="post-title" itemprop="name headline">

                <a class="post-title-link" href="/2017/03/22/2017-03-22-Object/" itemprop="url">JavaScript 对象</a></h1>


        <div class="post-meta">
          <span class="post-time">

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

                <span class="post-meta-item-text">Posted on</span>

              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-22T00:00:00+08:00">
                2017-03-22
              </time>





          </span>
















        </div>
      </header>





    <div class="post-body" itemprop="articleBody">







            <h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>对象是 JavaScript 的数据类型。它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值，因此我们可以把它看成是从字符串到值的映射。对象是动态的，可以随时新增和删除自有属性。对象除了可以保持自有的属性，还可以从一个称为原型的对象继承属性，这种「原型式继承（prototypal inheritance）」是 JavaScript 的核心特征。</p>
<p>对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。</p>
<p>属性包括名字和值。属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。值可以是任意 JavaScript 值，或者在 ECMAScript 5 中可以是 <code>getter</code> 或 <code>setter</code> 函数。</p>
<p>除了名字和值之外，每个属性还有一些与之相关的值，称为「属性特性（property attribute）」：</p>
<ul>
<li>可写（writable attribute），表明是否可以设置该属性的值。</li>
<li>可枚举（enumerable attribute），表明是否可以通过 <code>for-in</code> 循环返回该属性。</li>
<li>可配置（configurable attribute），表明是否可以删除或修改该属性。</li>
</ul>
<p>在 ECMAScript 5 之前，通过代码给对象创建的所有属性都是可写的、可枚举的和可配置的。在 ECMAScript 5 中则可以对这些特性加以配置。</p>
<p>除了包含属性特性之外，每个对象还拥有三个相关的「对象特性（object attribute）」：</p>
<ul>
<li>对象的类（class），是一个标识对象类型的字符串。</li>
<li>对象的原型（prototype），指向另外一个对象，本对象的属性继承自它的原型对象。</li>
<li>对象的扩展标记（extensible flag），指明了在 ECMAScript 5 中是否可以向该对象添加新属性。</li>
</ul>
<p>最后，用下面术语来对 JavaScript 的「三类对象」和「两类属性」进行区分：</p>
<ul>
<li>内置对象（native object），是由 JavaScript 规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。</li>
<li>宿主对象（host object），是由 JavaScript 解释器所嵌入的宿主环境（比如 Web 浏览器）定义的。客户端 JavaScript 中表示网页结构的 HTMLElement 对象均是宿主对象。</li>
<li>自定义对象（user-defined object），是由运行中的 JavaScript 代码创建的对象。</li>
<li>自有属性（own property），是直接在对象中定义的属性。</li>
<li>继承属性（inherited property），是在对象的原型对象中定义的属性。</li>
</ul>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>可以使用对象字面量、<code>new</code> 关键字和 ECMAScript 5 中的 <code>Object.create()</code> 函数来创建对象。</p>
<h3 id="使用对象字面量创建对象（推荐）"><a href="#使用对象字面量创建对象（推荐）" class="headerlink" title="使用对象字面量创建对象（推荐）"></a>使用对象字面量创建对象（推荐）</h3><p>创建对象最简单的方式就是在 JavaScript 代码中使用对象字面量。对象字面量是由若干名值对组成的映射表，名值对中间用冒号分隔，名值对之间用逗号分隔，整个映射表用花括号括起来。属性名可以是 JavaScript 标识符也可以是字符串直接量（包括空字符串）。属性的值可以是任意类型的 JavaScript 表达式，表达式的值（可以是原始值也可以是对象值）就是这个属性的值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐写法</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">"xxx"</span>,</span><br><span class="line">age : <span class="number">21</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以写成</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">"xxx"</span>;</span><br><span class="line">person.age = <span class="number">21</span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用-new-关键字创建对象"><a href="#使用-new-关键字创建对象" class="headerlink" title="使用 new 关键字创建对象"></a>使用 <code>new</code> 关键字创建对象</h3><p>new 关键字创建并初始化一个新对象。关键字 new 后跟随一个函数调用。这里的函数称做构造函数（constructor），构造函数用以初始化一个新创建的对象。JavaScript 语言核心中的原始类型都包含内置构造函数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"xxx"</span>;</span><br><span class="line">person.age = <span class="number">21</span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>var person = new Object();</code> 等价于 <code>var person = {};</code> 。</p>
<h3 id="使用-Object-create-函数创建对象"><a href="#使用-Object-create-函数创建对象" class="headerlink" title="使用 Object.create() 函数创建对象"></a>使用 <code>Object.create()</code> 函数创建对象</h3><p>ECMAScript 5 定义了一个名为 <code>Object.create()</code> 的方法，它创建一个新对象，其中第一个参数是这个对象的原型。<code>Object.create()</code> 提供第二个可选参数，用以对对象的属性进行进一步描述。<code>Object.create()</code> 是一个静态函数，而不是提供给某个对象调用的方法。使用它的方法很简单，只须传入所需的原型对象即可。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br><span class="line">person.name = <span class="string">"xxx"</span>;</span><br><span class="line">person.age = <span class="number">21</span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>var person = Object.create(Object.prototype);</code> 也等价于 <code>var person = {};</code> 。</p>
<h3 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h3><p>所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 <code>Object.prototype</code> 获得对原型对象的引用。通过关键字 <code>new</code> 和构造函数调用创建的对象的原型就是构造函数的 <code>prototype</code> 属性的值。因此，同使用 <code>{}</code> 创建对象一样，通过 <code>new Object()</code> 创建的对象也继承自 <code>Object.prototype</code>。同样，通过 <code>new Array()</code> 创建的对象的原型就是 <code>Array.prototype</code>，通过 <code>new Date()</code> 创建的对象的原型就是 <code>Date.prototype</code>。</p>
<p>没有原型的对象为数不多，<code>Object.prototype</code> 就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 <code>Object.prototype</code> 的原型。例如，<code>Date.prototype</code> 的属性继承自 <code>Object.prototype</code>，因此由 <code>new Date()</code> 创建的 <code>Date</code> 对象的属性同时继承自 <code>Date.prototype</code> 和 <code>Object.prototype</code>。</p>
<p>这一系列链接的原型对象就是所谓的「原型链（prototype chain）」。</p>
<h2 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h2><p>前面有提到过，可以通过点 <code>.</code> 或方括号 <code>[]</code> 运算符来获取属性的值。对于点 <code>.</code> 来说，左侧应当是一个对象，右侧必须是一个以属性名称命名的简单标识符。对于方括号来说 <code>[]</code> ，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名称。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐写法</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">// "xxx"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age);    <span class="comment">// "21"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以写成</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"name"</span>]);    <span class="comment">// xxx</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"age"</span>]);     <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<p>和获取属性的值写法一样，通过点和方括号也可以创建属性或给属性赋值，但需要将它们放在赋值表达式的左侧。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐写法</span></span><br><span class="line">person.name = <span class="string">"sophie"</span>; <span class="comment">// 赋值</span></span><br><span class="line">person.age = <span class="number">30</span>;        <span class="comment">// 赋值</span></span><br><span class="line">person.weight = <span class="number">38</span>;     <span class="comment">// 创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以写成</span></span><br><span class="line">person[<span class="string">"name"</span>] = <span class="string">"sophie"</span>;  <span class="comment">// 赋值</span></span><br><span class="line">person[<span class="string">"age"</span>] = <span class="number">30</span>;         <span class="comment">// 赋值</span></span><br><span class="line">person[<span class="string">"weight"</span>] = <span class="number">38</span>;      <span class="comment">// 创建</span></span><br></pre></td></tr></table></figure>
<p>当使用方括号时，方括号内的表达式必须返回字符串。更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值。</p>
<h2 id="属性的访问错误"><a href="#属性的访问错误" class="headerlink" title="属性的访问错误"></a>属性的访问错误</h2><p>查询一个不存在的属性并不会报错，如果在对象 <code>o</code> 自身的属性或继承的属性中均未找到属性 <code>x</code>，属性访问表达式 <code>o.x</code> 返回 <code>undefined</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.wife;    <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。<code>null</code> 和 <code>undefined</code> 值都没有属性，因此查询这些值的属性会报错。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.wife.name;   <span class="comment">// Uncaught TypeError: Cannot read property 'name' of undefined.</span></span><br></pre></td></tr></table></figure>
<p>除非确定 <code>person</code> 和 <code>person.wife</code> 都是对象，否则不能这样写表达式 <code>person.wife.name</code>，因为会报「未捕获的错误类型」，下面提供了两种避免出错的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冗余但易懂的写法</span></span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">if</span> (person) &#123;</span><br><span class="line"><span class="keyword">if</span> (person.wife) </span><br><span class="line">name = person.wife.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简练又常用的写法（推荐写法）</span></span><br><span class="line"><span class="keyword">var</span> name = person &amp;&amp; person.wife &amp;&amp; person.wife.name;</span><br></pre></td></tr></table></figure>
<h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p><code>delete</code> 运算符用来删除对象属性，事实上 <code>delete</code> 只是断开属性和宿主对象的联系，并没有真正的删除它。<code>delete</code> 运算符只能删除自有属性，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）。</p>
<h2 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h2><p>JavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系（判断某个属性是否存在于某个对象中）。可以通过 <code>in</code> 运算符、<code>hasOwnPreperty()</code> 和 <code>propertyIsEnumerable()</code> 来完成这个工作，甚至仅通过属性查询也可以做到这一点。</p>
<p><code>in</code> 运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 <code>true</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span> <span class="keyword">in</span> o);          <span class="comment">// true，x是o的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"y"</span> <span class="keyword">in</span> o);          <span class="comment">// false，y不是o的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> o);   <span class="comment">// true，toString是继承属性</span></span><br></pre></td></tr></table></figure>
<p>对象的 <code>hasOwnProperty()</code> 方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 <code>false</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(o.hasOwnProperty(<span class="string">"x"</span>));          <span class="comment">// true，x是o的自有属性</span></span><br><span class="line"><span class="built_in">console</span>.log(o.hasOwnProperty(<span class="string">"y"</span>));          <span class="comment">// false，y不是o的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(o.hasOwnProperty(<span class="string">"toString"</span>));   <span class="comment">// false，toString是继承属性</span></span><br></pre></td></tr></table></figure>
<p><code>propertyIsEnumerable()</code> 是 <code>hasOwnProperty()</code> 的增强版，只有检测到是自有属性且这个属性的可枚举性（enumerable attribute）为 <code>true</code> 时它才返回 <code>true</code>。某些内置属性是不可枚举的。通常由 JavaScript 代码创建的属性都是可枚举的，除非在 ECMAScript 5 中使用一个特殊的方法来改变属性的可枚举性。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = inherit(&#123; <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br><span class="line">o.x = <span class="number">1</span>;</span><br><span class="line">o.propertyIsEnumerable(<span class="string">"x"</span>);    <span class="comment">// true:，x是o的自有属性，可枚举</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">"y"</span>);    <span class="comment">// false，y是继承属性</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.propertyIsEnumerable(<span class="string">"toString"</span>);  <span class="comment">// false，不可枚举</span></span><br></pre></td></tr></table></figure>
<p>除了使用 <code>in</code> 运算符之外，另一种更简便的方法是使用 <code>!==</code> 判断一个属性是否是 <code>undefined</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(o.x !== <span class="literal">undefined</span>);              <span class="comment">// true，x是o的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(o.y !== <span class="literal">undefined</span>);              <span class="comment">// false，y不是o的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(o.toString !== <span class="literal">undefined</span>);       <span class="comment">// true，toString是继承属性</span></span><br></pre></td></tr></table></figure>
<p>然而有一种场景只能使用 <code>in</code> 运算符而不能使用上述属性访问的方式。<code>in</code> 可以区分不存在的属性和存在但值为 <code>undefined</code> 的属性。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="literal">undefined</span> &#125;        <span class="comment">// 属性被显式赋值为undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(o.x !== <span class="literal">undefined</span>); <span class="comment">// false，属性存在，但值为undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(o.y !== <span class="literal">undefined</span>); <span class="comment">// false，属性不存在</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span> <span class="keyword">in</span> o);          <span class="comment">// true，属性存在</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"y"</span> <span class="keyword">in</span> o);          <span class="comment">// false，属性不存在</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> o.x);        <span class="comment">// true，删除了属性x</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span> <span class="keyword">in</span> o);          <span class="comment">// false，属性不再存在</span></span><br></pre></td></tr></table></figure>
<h2 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h2><p>除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用 <code>for-in</code> 循环遍历，ECMAScript 5 提供了两个更好用的替代方案。</p>
<p><code>for-in</code> 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span>&#125;;            <span class="comment">// 三个可枚举的自有属性</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">"toString"</span>); <span class="comment">// false，不可枚举</span></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;          <span class="comment">// 遍历属性</span></span><br><span class="line"><span class="built_in">console</span>.log(p);     <span class="comment">// 输出x、y和z，不会输出toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有许多实用工具库给 <code>Object.prototype</code> 添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。然而在 ECMAScript 5 标准之前，这些新添加的方法是不能定义为不可枚举的，因此它们都可以在 <code>for-in</code> 循环中枚举出来。为了避免这种情况，需要过滤 <code>for-in</code> 循环返回的属性，下面两种方式是最常见的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p <span class="keyword">in</span> o) &#123;</span><br><span class="line"><span class="keyword">if</span> (!o.hasOwnProperty(p)) <span class="keyword">continue</span>;          <span class="comment">// 跳过继承的属性</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> o[p] === <span class="string">"function"</span>) <span class="keyword">continue</span>;    <span class="comment">// 跳过方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 <code>for-in</code> 循环之外，ECMAScript 5 定义了两个用以枚举属性名称的函数。第一个是 <code>Object.keys()</code>，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。第二个是 <code>Object.getOwnPropertyNames()</code>，它和 <code>Ojbect.keys()</code> 类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。在 ECMAScript 3 中是无法实现的类似的函数的，因为 ECMAScript 3 中没有提供任何方法来获取对象不可枚举的属性。</p>
<h2 id="属性的-getter-和-setter"><a href="#属性的-getter-和-setter" class="headerlink" title="属性的 getter 和 setter"></a>属性的 <code>getter</code> 和 <code>setter</code></h2><p>我们知道，对象属性是由名字、值和一组特性（attribute）构成的。在 ECMAScript 5 中，属性值可以用一个或两个方法替代，这两个方法就是 <code>getter</code> 和 <code>setter</code>。由 <code>getter</code> 和 <code>setter</code> 定义的属性称做「存取器属性（accessor property）」，它不同于「数据属性（data property）」，数据属性只有一个简单的值。</p>
<p>当程序查询存取器属性的值时，JavaScript 调用 <code>getter</code> 方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript 调用 <code>setter</code> 方法，将赋值表达式右侧的值当做参数传入 <code>setter</code>。从某种意义上讲，这个方法负责「设置」属性值。可以忽略 <code>setter</code> 方法的返回值。</p>
<p>和数据属性不同，存取器属性不具有可写性（writable attribute）。如果属性同时具有 <code>getter</code> 和 <code>setter</code> 方法，那么它是一个读/写属性。如果它只有 <code>getter</code> 方法，那么它是一个只读属性。如果它只有 <code>setter</code> 方法，那么它是一个只写属性，读取只写属性总是返回 <code>undefined</code>。定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line"><span class="comment">// 普通的数据属性</span></span><br><span class="line">data_prop: value,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存取器属性都是成对定义的函数</span></span><br><span class="line">get accessor_prop() &#123; <span class="comment">/*这里是函数体 */</span> &#125;,</span><br><span class="line">set accessor_prop(value) &#123; <span class="comment">/* 这里是函数体*/</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 <code>function</code> 关键字，而是使用 <code>get</code> 或 <code>set</code>。注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。</p>
<h2 id="序列化对象（JSON）"><a href="#序列化对象（JSON）" class="headerlink" title="序列化对象（JSON）"></a>序列化对象（JSON）</h2><p>对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript 5 提供了内置函数 <code>JSON.stringify()</code> 和 <code>JSON.parse()</code> 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON 的全称是「JavaScript 对象表示法（JavaScript Object Notation）」，它的语法和 JavaScript 对象与数组直接量的语法非常相近。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:&#123;<span class="attr">z</span>:[<span class="literal">false</span>,<span class="literal">null</span>,<span class="string">""</span>]&#125;&#125;;       <span class="comment">// 定义一个对象</span></span><br><span class="line">s = <span class="built_in">JSON</span>.stringify(o);                  <span class="comment">// s是 '&#123;"x":1,"y":&#123;"z":[false,null,""]&#125;&#125;'</span></span><br><span class="line">p = <span class="built_in">JSON</span>.parse(s);                      <span class="comment">// p是o的深拷贝</span></span><br></pre></td></tr></table></figure>
<p>JSON 的语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值。它支持对象、数组、字符串、无穷大数字、<code>true</code>、<code>false</code> 和 <code>null</code>，可以序列化和还原它们。<code>NaN</code>、<code>Infinity</code> 和 <code>-Infinity</code> 序列化的结果是 <code>null</code>，日期对象序列化的结果是 ISO 格式的日期字符串（参照 <code>Date.toJSON()</code> 函数），但 <code>JSON.parse()</code> 依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、<code>RegExp</code>、<code>Error</code> 对象和 <code>undefined</code> 值不能序列化和还原。<code>JSON.stringify()</code> 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。<code>JSON.stringify()</code> 和 <code>JSON.parse()</code> 都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。</p>




    </div>










    <footer class="post-footer">








        <div class="post-eof"></div>

    </footer>
  </div>



  </article>











  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">



  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/07/2016-12-07-Swift 2.2 新特性NOTE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="立志当大神">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rhino">
    </span>


      <header class="post-header">



          <h1 class="post-title" itemprop="name headline">

                <a class="post-title-link" href="/2016/12/07/2016-12-07-Swift 2.2 新特性NOTE/" itemprop="url">Swift 2.2 新特性NOTE</a></h1>


        <div class="post-meta">
          <span class="post-time">

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

                <span class="post-meta-item-text">Posted on</span>

              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-07T00:00:00+08:00">
                2016-12-07
              </time>





          </span>
















        </div>
      </header>





    <div class="post-body" itemprop="articleBody">







            <h1 id="Swift-2-2-新特性NOTE"><a href="#Swift-2-2-新特性NOTE" class="headerlink" title="Swift 2.2 新特性NOTE"></a>Swift 2.2 新特性NOTE</h1><p>慕课网:<a href="http://www.imooc.com/learn/750" target="_blank" rel="noopener">http://www.imooc.com/learn/750</a></p>
<h2 id="1-弃用-–运算符"><a href="#1-弃用-–运算符" class="headerlink" title="1. 弃用 ++,–运算符"></a>1. 弃用 ++,–运算符</h2><pre><code>var a = 3
//a++
a += 1
//a--
a -= 1                                        
</code></pre><h3 id="为什么取消"><a href="#为什么取消" class="headerlink" title="为什么取消"></a>为什么取消</h3><ol>
<li>–a ; a– 容易让人迷惑</li>
<li>+= 更符合语意</li>
</ol>
<h2 id="2-Deprecate-C-Style-For-Loop"><a href="#2-Deprecate-C-Style-For-Loop" class="headerlink" title="2. Deprecate-C-Style-For-Loop"></a>2. Deprecate-C-Style-For-Loop</h2><pre><code>// 使用区间运算符
for i in 1...10{
    print(i)
}

for i in 1..&lt;10{
    print(i)
}

// 反向遍历可以使用reversed
for i in (1...10).reversed(){
    print(i)
}

for i in (1..&lt;10).reversed(){
    print(i)
}
// 使用stride to表示不包括类似于区间 ..&lt;
for i in stride(from:0, to:10, by:2){
    print(i)
}
//through表示包含 类似于区间 ...
for i in stride(from:0, through:10, by:2){
    print(i)
}
//递减 步长为-2
for i in stride(from:10, to:0, by:-2){
    print(i)
}
//使用浮点数
for i in stride(from:0.5, to:1.5, by:0.1){
    print(i)
}
</code></pre><h2 id="3-Tuple的比较-Deprecate-Tuple-Splat-没用过"><a href="#3-Tuple的比较-Deprecate-Tuple-Splat-没用过" class="headerlink" title="3.Tuple的比较, Deprecate-Tuple-Splat(没用过)"></a>3.Tuple的比较, Deprecate-Tuple-Splat(没用过)</h2><pre><code>// tuple 的比较
let score1 = (chinese:90, math:95)
let score2 = (chinese:90, math:100)
let score3 = (chinese:100, math:90)

score1 &lt; score2  //ture
score3 &lt; score2 //false
</code></pre><h2 id="4-Selectors-Can-Not-Be-a-String"><a href="#4-Selectors-Can-Not-Be-a-String" class="headerlink" title="4. Selectors-Can-Not-Be-a-String"></a>4. Selectors-Can-Not-Be-a-String</h2><pre><code>//以前使用字符串,容易出现拼写错误
   //button.addTarget(self, action: &quot;click&quot;, for: .touchUpInside)
    button.addTarget(self, action: #selector(click), for: .touchUpInside)
</code></pre>



    </div>










    <footer class="post-footer">








        <div class="post-eof"></div>

    </footer>
  </div>



  </article>











  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">



  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/02/10/ 2016-2-10 Category/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="立志当大神">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rhino">
    </span>


      <header class="post-header">



          <h1 class="post-title" itemprop="name headline">

                <a class="post-title-link" href="/2016/02/10/ 2016-2-10 Category/" itemprop="url">Block</a></h1>


        <div class="post-meta">
          <span class="post-time">

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

                <span class="post-meta-item-text">Posted on</span>

              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-10T00:00:00+08:00">
                2016-02-10
              </time>





          </span>
















        </div>
      </header>





    <div class="post-body" itemprop="articleBody">







            <h1 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h1><p>objc2.0,作用:为已经存在的类添加方法</p>
<ul>
<li>声明私有方法</li>
<li>模拟多继承</li>
<li>不同的功能组织到不同的category里,减少单个文件的体积,由多个开发者共同完成一个类</li>
<li>按需加载想要的category</li>
</ul>
<p>###Category与Extesion<br>Extesion是一个匿名类别,在编译期间决定,作为类的组成部分,在编译期间与头文件里的@interface和实现文件里面的@implement组成一个完成的类,与类共存亡.<br>Extesion一般用来隐藏类的私有信息,只有拥有一个类的源码才能添加,不能为系统类添加Extesion.<br>Category在运行期决议的,所以无法添加实例变量(因为在运行期,对象的内存布局已经确定,如果添加实例变量就会破坏类的内存布局,这对编译型语言是灾难性的)</p>
<p>###方法覆盖<br>1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA<br>2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</p>
<p>###Category的Load<br>1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？<br>2)、这么些个+load方法，调用顺序是咋样的呢？</p>
<p>1)、可以调用，因为附加category到类的工作会先于+load方法的执行<br>2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。</p>
<p>###关联对象<br>category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。</p>




    </div>










    <footer class="post-footer">








        <div class="post-eof"></div>

    </footer>
  </div>



  </article>











  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">



  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/02/09/2016-2-09 Block的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="立志当大神">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rhino">
    </span>


      <header class="post-header">



          <h1 class="post-title" itemprop="name headline">

                <a class="post-title-link" href="/2016/02/09/2016-2-09 Block的理解/" itemprop="url">Block</a></h1>


        <div class="post-meta">
          <span class="post-time">

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

                <span class="post-meta-item-text">Posted on</span>

              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-09T00:00:00+08:00">
                2016-02-09
              </time>





          </span>
















        </div>
      </header>





    <div class="post-body" itemprop="articleBody">







            <h3 id="Block的理解"><a href="#Block的理解" class="headerlink" title="Block的理解"></a>Block的理解</h3><p>####什么是Block<br>带有自动变量的匿名函数</p>
<ul>
<li>自动变量</li>
<li>匿名函数</li>
</ul>
<p>####Block的使用</p>
<ol>
<li>作为变量</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">returnType(^blockName)(Parameters) = ^(Parameters)&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;;</span><br><span class="line">//调用</span><br><span class="line">blockName(Parameters);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>作为属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,copy)returnType (^blockName)(Parameters);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>作为函数参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)testMethodWithHandler:(returnType (^blockName)(Parameters))block;</span><br><span class="line"></span><br><span class="line">[self testMethodWithHandler:^returnType (Parameters)&#123;....&#125;];</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用typedef</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef returntype (^BlockName)(Parameters);</span><br><span class="line">@property (nonatomic,copy)BlockName block;</span><br></pre></td></tr></table></figure>
<p>####Block的本质</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define BLOCK_DESCRIPTOR_1 1</span><br><span class="line">struct Block_descriptor_1 &#123;</span><br><span class="line">uintptr_t reserved;</span><br><span class="line">uintptr_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_layout &#123;</span><br><span class="line">void *isa;</span><br><span class="line">volatile int32_t flags; // contains ref count</span><br><span class="line">int32_t reserved;</span><br><span class="line">void (*invoke)(void *, ...);</span><br><span class="line">struct Block_descriptor_1 *descriptor;</span><br><span class="line">// imported variables</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>objc中对象的定义:首地址是isa的结构体指针,所以block是对象类型</p>
<p>block的class类型:</p>
<ul>
<li>_NSConcreteStackBlock     栈上创建的block</li>
<li>_NSConcreteMallocBlock   堆上创建的block</li>
<li>_NSConcreteGlobalBlock   作为全局变量的block</li>
<li>_NSConcreteWeakBlockVariable</li>
<li>_NSConcreteAutoBlock</li>
<li>_NSConcreteFinalizingBlock</li>
</ul>
<p>#####_NSConcreteGlobalBlock<br>创建block时,就是声明struct,初始化struct的成员;执行block,就是调用struct的函数指针,编译完成之后,block中的代码会被提取出来,成为单独的C函数,调用这个C函数,并把struct指针传递过去.block的实际作用就相当于C语言的匿名函数.</p>
<p>全局block:block内部没有捕获任何外部变量就是一个全局block类型,调用block(),和C语言的函数无异,不需要考虑其生命周期</p>
<p>#####_NSConcreteStackBlock</p>
<p>当block内部引用了外部变量,当struct被创建时,它是存在于函数的栈帧上的,其class是固定的_NSConcreteStackBlock类型.其捕获的变量是会赋值到结构体的成员上,所以当block初始化完成之后,捕获的变量不能更改.<br>当函数返回时,函数的栈帧被销毁,这个block的内存也会被清除.所以当函数结束后仍然需要这个block时,就必须用Block_copy()方法将它拷贝到堆上,核心动作即(申请内存,将栈数据复制过去,将class改成_NSConcreteMallocBlock,向捕获的对象发送retain,增加block的引用计数)</p>
<p>block就是个匿名函数，只不过我们给了一个变量来引用这个匿名函数，在需要的时候调用。但是,栈block会随着函数栈帧的销毁而销毁，这样一来，我们用之前做引用的变量再去调用这么一块被销毁的内存，就会出现内存崩溃。</p>




    </div>










    <footer class="post-footer">








        <div class="post-eof"></div>

    </footer>
  </div>



  </article>











  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">



  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/02/07/2016-2-07  KVC与KVO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="立志当大神">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rhino">
    </span>


      <header class="post-header">



          <h1 class="post-title" itemprop="name headline">

                <a class="post-title-link" href="/2016/02/07/2016-2-07  KVC与KVO/" itemprop="url">KVC与KVO</a></h1>


        <div class="post-meta">
          <span class="post-time">

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>

                <span class="post-meta-item-text">Posted on</span>

              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-07T00:00:00+08:00">
                2016-02-07
              </time>





          </span>
















        </div>
      </header>





    <div class="post-body" itemprop="articleBody">







            <p>##KVC与KVO</p>
<p>###KVC(key-value-coding)键值编码<br>用来给一个对象的属性进行赋值或者访问.<br>通过类别的方式添加<br>@interface NSObject(NSKeyValueCoding)</p>
<p>使用:</p>
<ul>
<li>(void)setValue:(nullable id)value forKey:(NSString *)key;<ul>
<li>(void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;<br>第二个方法通过路径的方式的访问,即可以访问成员变量是对象的属性 “Dog.age”</li>
</ul>
</li>
</ul>
<p>应用:</p>
<ol>
<li>系统Storyboard控件拖线</li>
<li>访问私有成员变量</li>
<li>字典转模型</li>
</ol>
<p>字典转模型(属性名相同,不能是关键字,嵌套对象模型时还需另做处理,一般使用第三方)</p>
<ul>
<li>(void)setValuesForKeysWithDictionary:(NSDictionary<nsstring *,="" id=""> *)keyedValues;<br>遇到不能识别的key执行的方法</nsstring></li>
<li>(void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</li>
</ul>
<p>原理:</p>
<p>###KVO(key-value-observing)键值监听<br>利用一个key来找到某个属性并监听其值的改变。典型的观察者模式<br>类别:@interface NSObject(NSKeyValueObserving)</p>
<p>使用:</p>
<ol>
<li>添加监听</li>
<li>实现监听方法，observeValueForKeyPath: ofObject: change: context:</li>
<li>移除监听</li>
</ol>
<p>相关API</p>
<ul>
<li>(void)addObserver:(NSObject <em>)observer forKeyPath:(NSString </em>)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;//添加监听</li>
<li>(void)removeObserver:(NSObject <em>)observer forKeyPath:(NSString </em>)keyPath context:(nullable void *)context API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0));//删除监听</li>
<li>(void)removeObserver:(NSObject <em>)observer forKeyPath:(NSString </em>)keyPath;//删除监听</li>
<li>(void)observeValueForKeyPath:(nullable NSString <em>)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; </em>)change context:(nullable void *)context;//监听实现方法</li>
</ul>
<p>####手动实现KVO<br>重写该方法,对应的key但会NO</p>
<ul>
<li>(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key;<br>调用方法完成当值改变时发出通知</li>
</ul>
<ul>
<li>(void)willChangeValueForKey:(NSString *)key;</li>
<li>(void)didChangeValueForKey:(NSString *)key;</li>
</ul>
<p>###KVO的实现原理<br>当一个类的属性被观察的时候，系统会通过runtime动态的创建一个该类的派生类，并且会在这个类中重写基类被观察的属性的setter方法，而且系统将这个类的isa指针指向了派生类，从而实现了给监听的属性赋值时调用的是派生类的setter方法。重写的setter方法会在调用原setter方法前后，通知观察对象值得改变。</p>




    </div>










    <footer class="post-footer">








        <div class="post-eof"></div>

    </footer>
  </div>



  </article>



  </section>


  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>





        </div>



  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">

    <div class="sidebar-inner">





      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">

              <p class="site-author-name" itemprop="name">立志当大神</p>
              <p class="site-description motion-element" itemprop="description">I have a dream! change the world~</p>
          </div>

          <nav class="site-state motion-element">


              <div class="site-state-item site-state-posts">

                <a href="/archives/">

                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>







              <div class="site-state-item site-state-tags">

                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>

              </div>


          </nav>













        </div>
      </section>





    </div>
  </aside>



      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">立志当大神</span>


</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>













      </div>
    </footer>


      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>

      </div>




  </div>



<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>




    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>




    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>




    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>




    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>






  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>







  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>








  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>

























































</body>
